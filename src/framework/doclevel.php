<?php
/**
 * @package html
 */
 
/**
 * HTML Document
 *
 * This class should be the root object of every HTML page generated by this
 * framework.
 * @package html
 */
class doc extends container {
	private $user;
	private $head;
	private $endJS;
	private $minwidth;
	private $timer = FALSE;
	private $starttimer;
	private $prettycode = FALSE;
	private $logging;
	private $inputs;
	private $seocallback;
	private $html5;
	
	/**
	 * Document Constructor
	 *
	 * Takes a user object as input.  Must be a descendant of the user class
	 * defined in sessions.php.
	 * @param user $user
	 */
	function __construct($user = FALSE) {
		global $cfg;
		if ($cfg['display_runtime']) $this->timer = TRUE;
		$this->starttimer = microtime(TRUE);
		if ($user instanceof user) $this->setuser($user);
		else $this->setuser(new default_user());
		$cfg['currentdoc'] = $this;
		$this->head = new head;
		$this->includeCSS('@phpwebobjects.css');
	}
	
	/**
	 * Send to Client
	 *
	 * Use this method to finally build the HTML and send
	 * it to the client.  This should be the final method executed
	 * for any web page.  If you call it early, you should use the
	 * exit command to stop processing, as no further work will make
	 * it to the client.
	 * 
	 * Output will immediately be echoed. Does NOT return a string.
	 * 
	 * @return void
	 */
	public function output() {
		container::finalize();
		if ($this->prettycode()) $br = "\n";
		if ($this->minwidth) {
			$max = 960;
			$negwidth = ($this->minwidth > $max ? $max : $this->minwidth);
			$diff = $this->minwidth - $max;
			if ($diff < 0) $diff = 0;
			$this->addCSS("
/* stupid minwidth hack - I hate IE \*/
* html .minwidthhack_minwidth {border-left:".$negwidth."px solid #fff; border-right: ".$diff."px solid #fff; height: 1px; position:relative; float:left; z-index:1;}
* html .minwidthhack_container {margin-left:-".$negwidth."px; margin-right: -".$diff."px; height: 1px; position:relative; float:left; z-index:2;}
/* end stupid minwidth hack */");
			$opendivs = $br.'<div style="width: 100%; min-width: '.$this->minwidth.'px;"><div class="minwidthhack_minwidth"><div class="minwidthhack_container">';
			$closedivs = $br."</div></div></div>";
		}
		if ($this->endJS) {
			$myendjs = htmlspecialchars($this->endJS);
			$onload = ' onload="'.$myendjs. '" onpageshow="if (event.persisted) { '.$myendjs.' }"';
		}
		echo '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'.$br.
			 '<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">' . $this->head->output() . '<body' . $onload . '>'.$opendivs .
		     container::output('',$this->prettycode()) . $closedivs;
		if ($this->timer) echo 'Build time: '.sprintf("%.0f",1000*(microtime(TRUE)-$this->starttimer)).'ms';
		echo '</body>' . "</html>";
		if (!empty($this->logging))
			foreach ($this->logging as $key => $cback)
				call_user_func_array($cback, $this->inputs[$key]);
		return;
	}
	
	/**
	 * Get Build Time
	 *
	 * Only works correctly if used after the $doc->output() statement
	 * 
	 * @return double
	 */
	public function getbuildtime() {
		return microtime(TRUE)-$this->starttimer;
	}
	
	/**
	 * Set a refresh/redirect
	 *
	 * This is a method for quickly setting a page to reset itself.
	 *
	 * It is also used to do redirection.  If you add a delay it will use
	 * meta redirection.  The user will see your page for a few seconds and then
	 * be redirected.
	 *
	 * If you set the delay to 0, it will use header
	 * redirection, e.g. header("Location: http://domain.com"). The user
	 * will not see the document at all and will be redirected transparently.
	 *
	 * Beware of using this method on pages that are intended to be indexed
	 * by search engines.  It can confuse the spider and in some cases get
	 * you put on their blacklist.
	 *
	 * @param integer $time
	 * @param string $url
	 * @param array $vars
	 * @return void
	 */
	public function refresh($time, $url = '', $vars = array(), $make_secure = 0, $hash = '') {
				
		// set default values
		if (!$url) { 
			$url = '';
			if (empty($vars)) {
				$vars = $_GET;
				$truerefresh = TRUE;
			}
		}
				
		// build the query
		if ($time == 0 && !$truerefresh) {
			$loc = self::absolute_url(link::buildquery($url, $vars, $make_secure, '&', $hash));
			header("Location: $loc");
			$time = 1;
		}
		$furl = link::buildquery($url, $vars, $make_secure, '&amp;', $hash);
		$this->head->refresh($furl, $time);
	}
	
	/**
	 * Escape regex special chars
	 *
	 * This will escape characters that could interrupt a regular expression.
	 *
	 * It assumes you use / as a delimiter, which is pretty standard.
	 *
	 * @param string $string
	 * @return string
	 * @static
	 */
	public static function safe_for_regex($string) {
		return preg_quote($string, '/');
	}

	/**
	 * Create an absolute URL from a relative one
	 *
	 * A public function that can turn a relative link into an
	 * absolute link.  Optionally you can set $make_secure to 1
	 * to force a secure https link, or -1 to force an unsecure http
	 * link.
	 *
	 * @param string $url
	 * @param integer $make_secure
	 * @return string
	 * @static
	 */
	public static function absolute_url($url, $make_secure = 0) {
		if (substr($url, 0, 7) == 'http://' && $make_secure == 1) return 'https://'.substr($url, 7);
		elseif (substr($url, 0, 8) == 'https://' && $make_secure == -1) return 'http://'.substr($url, 8);
		elseif (substr($url, 0, 7) == 'http://' || substr($url, 0, 8) == 'https://') return $url;
		
		// absolute url starts with http or https
		if ($make_secure == 1) $http = 'https://';
		elseif ($make_secure == -1) $http = 'http://';
		elseif ($_SERVER['HTTPS']) $http = 'https://';
		else $http = 'http://';
		
		// get the domain name
		$serv = $_SERVER['HTTP_HOST'];
		
		// if the link was domain-relative, we can just tack it on now
		if (substr($url, 0, 1) == '/') return $http.$serv.$url;
		
		// if the link is directory-relative, we need to find the path it was in
		$uri = rtrim(dirname($_SERVER['PHP_SELF'])).'/';
		// this is a fix for when it's directory-relative but it's at the root
		if ($uri == '//') $uri = '/';
		
		// if the link is directory-relative and has backlinks, we're going to clear
		// those out in order to make the absolute URL a bit more consistent.
		// If they try to back out further than the server root, we'll clean those
		// backlinks out as they're invalid.
		while (substr($url,0,3) == "../") {
			$url = substr($url, 3);
			$uri = preg_replace('/[^\/]*\/$/', '', $uri);
		}
		
		// done
		return $http.$serv.$uri.$url;
	}
		
	/**
	 * Set a user-defined seo strategy
	 *
	 * Use this method to set a callback function that detects links that should
	 * be made SEO compatible.  
	 * 
	 * In other words, the callback function you set up should be able to take 
	 * an href and some variables and turn it into something that looks nice 
	 * like "/products/frisbees/super-fun-frisbee.html".  
	 * 
	 * Then your mod_rewrite rules will undo that and turn it back into the href 
	 * and variables that you started with, so your scripts are none the wiser and can
	 * all operate as if the mod_rewrite layer doesn't exist.
	 *
	 * $callback should be specified in standard PHP callback format. Note that the
	 * parameters sent to your callback function will be $href and $vars, you must
	 * use that information to construct the FULL href string, no query string will
	 * be added after the fact.  The variables will include session information if
	 * it's needed.
	 * 
	 * @param callback $callback
	 * @return void
	 */
	public function setseo($callback) {
		$this->seocallback = $callback;
	}
	
	/**
	 * Get the user-defined seo strategy callback
	 *
	 * Counterpart to {@link setseo()}.
	 * 
	 * @return callback
	 */
	public function getseo() {
		return $this->seocallback;
	}

	/**
	 * Set Document Title
	 *
	 * Use this method to set the title of the document.
	 *
	 * This will define what is placed in the <title> tag in the <head>
	 * section of your document.
	 */
	public function setTitle($title) {
		$this->head->setTitle($title);
	}
	
	/**
	 * Get Document Title
	 *
	 * Use this method to get the current title for your document.
	 *
	 * This will match what is placed in the <title> tag in the <head>
	 * section of your document.
	 */
	public function getTitle() {
		return $this->head->getTitle();
	}
	
	/**
	 * Append Document Title
	 *
	 * Use this method to add to a document's title without overwriting it.
	 * Entries that are appended with this method will be separated by a dash
	 * like so: Title - Appended
	 */
	public function appendTitle($title) {
		$this->head->appendTitle($title);
	}
	
	/**
	 * Add Meta Keywords
	 *
	 * Use this method to add keywords to the meta tag for keywords.  This
	 * is something search engines use a lot to calculate relevancy.
	 */
	public function addkeywords($keywords) {
		$this->head->addkeywords($keywords);
	}
	
	/**
	 * Set search engine description
	 *
	 * Use this method to set a page description for use by search engines.
	 *
	 * They will typically search it for keywords, as well as display it under the link
	 * in the search result list.  You want to make the description very imformative and
	 * specific to let people know that you have what they are looking for.
	 *
	 * @param string $descr
 	 */
	public function setdescription($descr) {
		$this->head->setdescription($descr);
	}
	
	/**
	 * Add a URL Icon
	 *
	 * This will add a tiny icon to the left of the browser's address bar,
	 * helping to quickly identify your site during tabbed browsing.
	 *
	 * You should pass it a web-accessible icon with extension .ico and with
	 * dimensions of 16x16, encoded as jpeg (or gif/png?).
	 * 
	 * @param string $location
	 */
	public function addURLIcon($location) {
		$this->head->addURLIcon($location);
	}
	
	/**
	 * Set a minimum display width
	 *
	 * This method allows you to specify a minimum width for your page, such that
	 * if a user with a low resolution monitor views it, it will scroll rather than
	 * try to squeeze your content into a smaller width.
	 *
	 * This is similar to the CSS min-width but is designed to work in Internet
	 * Explorer as well (min-width is not supported in IE6).
	 *
	 * @param integer $width
	 */
	public function setminwidth($width) {
		$this->minwidth = $width;
	}
	
	/**
	 * For internal use - allows framework elements to detect
	 * whether they should use prettycode formatting or not.
	 *
	 * @access private
	 */
	public function prettycode() {
		return $this->prettycode;
	}
	
	/**
	 * Print execution time
	 * 
	 * If you call this method, the page's build time
	 * will be printed at the bottom of the page, just before the 
	 * close of the body tag.
	 */
	public function showbuildtime($flag = TRUE) {
		$this->timer = $flag;
	}
	
	/**
	 * Specify a logging function
	 *
	 * Use this method to specify a function that should be called
	 * just after successfully building the document and outputting it
	 * to the client.
	 *
	 * This is useful when you are trying to log execution time of
	 * your scripts, or any number of other things you may want to
	 * keep track of.
	 *
	 * The function should be specified in the standard PHP callback
	 * format, and the $inputs array should contain the parameters, left
	 * to right.  For instance, a function with 3 parameters should come
	 * with an $inputs array with 3 elements.
	 *
	 * You may register more than one logging function.
	 *
	 * @param callback $callback
	 * @param array $inputs
	 */
	public function register_logging($callback, $inputs = array()) {
		if (!empty($callback)) {
			$this->logging[] = $callback;
			$this->inputs[] = $inputs;
		}
		return;
	}
	
	/**
	 * Add whitespace formatting to HTML code
	 *
	 * This method will force the HTML generated to be properly indented for easy
	 * reading.  Use it for debugging HTML issues, but turn it off for long-term
	 * use.  By default the framework will generate minimal whitespace, making for
	 * more efficient download times.
	 *
	 * There may be slight visual differences in a browser when toggling this
	 * functionality, generally due to spaces between images or form objects.
	 */
	public function useprettycode() {
		$this->prettycode = TRUE;
	}
	
	/**
	 * Include Cascading Style Sheet
	 *
	 * Use this method to include a pre-created, cacheable
	 * .css file, that defines your CSS classes.
	 *
	 * Inclusion will take place in the <head> section.
	 *
	 * If you use this method multiple times with the same path,
	 * it will only be included once.
	 * 
	 * If you like, you may set 'css_root' in the $cfg global variable, then
	 * use a '!' at the beginning of the path.  We'll then assume that
	 * the '!' stands in for $cfg['css_root'].'/'
	 *
	 * @param string $web_path_to_file
	 * @return void
	 */
	public function includeCSS($web_path_to_file) {
		$this->head->includeCSS($web_path_to_file);
	}
	
	/**
	 * Include Javascript Library
	 *
	 * Use this method to add a javascript library file to your
	 * document.
	 *
	 * If you use this method multiple times with the same path,
	 * it will only be included once.
	 *
	 * @param filepath $jsfile
	 * @return void
	 */
	public function includeJS($jsfile) {
		$this->head->includeJS($jsfile);
	}
	
	/**
	 * Add Cascading Style Sheet Definitions to Document
	 *
	 * Use this method to add CSS definitions to your document.  These
	 * will be placed inside a <style> tag inside the <head> section
	 * of the document.
	 *
	 * Be careful using this method inside of a loop, as the definition
	 * may be defined several times redundantly.
	 *
	 * @param string $csstext
	 * @return void
	 */
	public function addCSS($csstext) {
		$this->head->addCSS($csstext);
	}
	
	/**
	 * Add Javascript to the Document
	 *
	 * Use this method to add Javascript in the <head> section
	 * of the HTML document.   Best used for adding needed functions.
	 *
	 * Be careful using this method inside of a loop, as the function
	 * may be defined multiple times, generating a Javascript error.
	 *
	 * @param string $jstext
	 * @return void
	 */
	public function addJS($jstext) {
		$this->head->addJS($jstext);
	}
	
	/**
	 * Add Javascript on Page Load
	 *
	 * This will add javascript to the onload attribute of the <body>
	 * element.
	 *
	 * Javascript inside this container will only be executed after the
	 * client's browser has finished loading the page.  Any inline code that
	 * affects page elements should be placed in here, to ensure the elements
	 * exist during processing.
	 *
	 * This method will also add your javascript in the appropriate manner to the
	 * pageshow event, to make sure that firefox behaves the same way
	 * Internet Explorer does - that is, the load event fires every time you
	 * navigate to a page, even with the back or forward button.
	 *
	 * This behavior is unavoidable in IE6, therefore there is no option in this
	 * framework to alter it.
	 *
	 * @param string $jstext
	 * @return void
	 */
	public function addJS_afterload($jstext) {
		$jstext = trim($jstext);
		if (substr($jstext, -1) != ';' && substr($jstext,-1) != '}') $jstext .= ';';
		if ($this->endJS) $this->endJS .= ' ';
		$this->endJS .= $jstext;
	}
		
	/**
	 * Set User
	 * 
	 * Set the user for this document.  This should come from the session
	 * manager and be a descendant of the user class defined in sessions.php.
	 * 
	 * Returns TRUE if the object was valid and was successfully set as the
	 * active user.
	 *
	 * @return bool
	 * @param user $user
	 */
	public function setuser($user) {
		global $cfg;
		if ($user instanceof user) {
			$this->starttimer = $user->starttime();
			$this->user = $user;
			$cfg['currentuser'] = $user;
			return TRUE;
		}
		return FALSE;
	}
	
	/**
	 * Get User
	 *
	 * Retrieves a handle for the current user information.  Used by several
	 * framework classes, available for user as well.
	 *
	 * @return user
	 * @static
	 */
	public static function getuser() {
		global $cfg;
		if ($cfg['currentuser'] instanceof user) return $cfg['currentuser'];
		else return FALSE;
	}
	
	/**
	 * Get Document
	 *
	 * Retrieves a handle for the current document.  Used by several
	 * framework classes, available for user as well.
	 * @return doc
	 * @static
	 */
	public static function getdoc() {
		global $cfg;
		if (is_object($cfg['currentdoc'])) return $cfg['currentdoc'];
		else return FALSE;
	}
	
	/**
	 * Generate HTML5 instead of XHTML1
	 *
	 * Use this method to flag the doc for HTML5, enabling all the new elements
	 * and making appropriate swaps for existing elements.
	 *
	 * This method may be called at any time before invoking the output() method.
	 *
	 * @param bool $flag
	 * @return void
	 */
	public function usehtml5($flag = TRUE) {
		$this->html5 = ($flag ? TRUE : FALSE);
	}
	
	/**
	 * Check if the current document is set for HTML5
	 *
	 * Static method for convenience, checks the doc returned by doc::getdoc()
	 *
	 * @return bool
	 */
	public static function html5() {
		return self::getdoc()->ishtml5();
	}
	
	/**
	 * Check whether a doc is set for HTML5
	 *
	 * Returns TRUE if user has indicated a preference for HTML5.
	 *
	 * @return bool
	 */
	public function ishtml5() {
		return $this->html5;
	}
	
	/**
	 * Detect SSL HTTP Request
	 * 
	 * Use this function to determine if you're communicating securely, in
	 * case we ever want to change our strategy for detecting this.
	 * 
	 * @return bool
	 */
	public static function issecure() {
		return $_SERVER['HTTPS'] ? 1 : 0;
	}
	
	/**
	 * Recreate form data
	 * 
	 * This static function will return an array containing all the 
	 * GET and POST data that was submitted to the current page, but
	 * it will remove framework variables like errorcheck_auth, etc,
	 * since those should properly be regenerated outside the user's
	 * sphere of influence.
	 *
	 * It is mainly useful for easily maintaining context information 
	 * through several pages of a form submission without having to add them to the 
	 * session.
	 *
	 * @return array
	 * @static
	 * @access private
	 */
	public static function create_mimic() {
		$mimic = (array) $_REQUEST;
		$user = self::getuser();
		if ($user instanceof user) unset($mimic[$user->sidname()]);
		unset($mimic['errorcheck_auth']);
		unset($mimic['whichform']);
		unset($mimic['pwo_submit']);
		foreach ($_COOKIE as $key => $val)
			unset($mimic[$key]);
		foreach ($mimic as $key => $val) {
			if (strcont($key, 'check_')) unset($mimic[$key]);
		}
		return $mimic;
	}
	
	/**
	 * Use PHP's built in session tracking so the framework can save
	 * persistent variables.  If we have a session name and ID already,
	 * we can make PHP piggyback onto that.
	 * 
	 * @return bool
	 * @access private
	 */
	public static function start_php_session() {
		if (session_id()) return 1;
		$user = doc::getuser();
		if ($user instanceof user) {
			session_name($user->sidname());
			session_id($user->sid());
		}
		return session_start();
	}
}

/**
 * HTML Head
 *
 * Stores all the information to be placed inside the <head></head> tag in the
 * final HTML document.  Content may be added here at any time, including javascript
 * functions and stylesheet definitions.
 * @package html
 * @access private
 */
class head extends container {
	private $title;
	private $js;
	private $refresh;
	private $urlicon;
	private $cssincludes = array();
	private $jsincludes = array();
	private $keywords = array();
	private $description;
	
	public function refresh($url, $time) {
		$this->refresh['url'] = $url;
		$this->refresh['time'] = $time;
	}
	public function setTitle($title) {
		$this->title = $title;
	}
	public function getTitle() {
		return $this->title;
	}
	
	public function appendTitle($title) {
	  if (!$this->title) $this->title = $title;
		else $this->title .= ' - ' . $title;
	}
	
	public function addkeywords($keywords) {
		if (!is_array($keywords)) {
			$keywords = explode(',', $keywords);
		}
		foreach ($keywords as $word) $this->keywords[] = $word;
	}
	
	public function setdescription($descr) {
		$this->description = $descr;
	}
	
	public function addURLIcon($location) {
		$this->urlicon = $location;
	}
	
	public function includeCSS($cssfile) {
		$this->cssincludes[] = $cssfile;
	}
	
	public function includeJS($jsfile) {
		$this->jsincludes[] = $jsfile;
	}
	
	public function addCSS($csstext) {
		$this->css .= trim($csstext) . "\n";
	}
	
	public function addJS($jstext) {
		$jstext = trim($jstext);
		if (substr($jstext, -1) != ';') $jstext .= ";";
		$this->js .= $jstext . "\n";
	}

	public function output() {
		global $cfg;
		$doc = doc::getdoc();
		// respect prettycode() inside the head tag
		if ($doc->prettycode()) $br = "\n";
		
		// set the document title
		if ($this->title) $title = $br.'<title>' . htmlspecialchars($this->title) . '</title>';
		
		// output document keywords for search engine compatibility
		$this->keywords = array_unique($this->keywords);
		if (!empty($this->keywords)) $keywords = $br.'<meta name="keywords" content="' . htmlspecialchars(implode(',', $this->keywords)) . '" />';
		// output document description for search engine compatibility		
		if ($this->description) $description = $br.'<meta name="description" content="'.htmlspecialchars($this->description).'" />';
		
		// if we have a refresh with a timer > 0, we'll use the meta tag method for it
		// if it's 0, we'll handle it elsewhere as an HTTP header (Location:)
		if ($this->refresh['time']) $refresh = '<meta http-equiv="refresh" content="'.$this->refresh['time'].';url='.$this->refresh['url'].'" />';
		// support custom URLIcon paths
		if ($this->urlicon) {
			if ($this->urlicon{0} == '!') $path = $cfg['image_root'] . '/' . substr($this->urlicon, 1);
			else $path = $this->urlicon;
			$iconlink = '<link rel="shortcut icon" href="'.$path.'" type="image/x-icon" /><link rel="icon" href="'.$path.'" type="image/x-icon" />';
		}
		// take care of included CSS files
		$this->cssincludes = array_unique($this->cssincludes);
		foreach ($this->cssincludes as $include) {
			if ($include{0} == '@') $path = $cfg['library_path_css'] . '/' . substr($include, 1);
			elseif ($include{0} == "!") $path = $cfg['css_root'] . '/' . substr($include,1);
			else $path = $include;
			$css .= $br.'<link href="' . $path . '" rel="stylesheet" type="text/css" />';
		}
		// take care of included javascript files
		$js_root = $cfg['javascript_root'];
		$this->jsincludes = array_unique($this->jsincludes);
		foreach ($this->jsincludes as $include) {
			if ($include{0} == "@") {
				$path = $cfg['library_path_js'] . '/' . substr($include, 1);
			} elseif ($include{0} == "!") {
				$path = $cfg['javascript_root'] . '/' . substr($include, 1);
			} else {
				$path = $include;
			}
			$js .= $br.'<script language="javascript" src="' . $path . '" type="text/javascript"></script>';
		}
		// place inline javascript in the header
		if ($this->js) $js .= $br.'<script type="text/javascript">'."\n// <![CDATA[\n" . trim($this->js) . "\n// ]]>\n</script>";
		// place inline CSS in the header
		if ($this->css) $css .= $br.'<style type="text/css">' . trim($this->css) . '</style>';
		// character encoding
		$encoding = '<meta http-equiv="content-type" content="text/xhtml; charset=UTF-8" />';
		// send it all off inside the head tag
		return $br.'<head>' . $encoding . $title . $keywords . $refresh . $description . $css . $js . $iconlink . $br.'</head>'.$br;
	}
	
	
}

?>